Microsoft (R) Macro Assembler Version 14.29.30146.0	    10/30/22 17:41:51
)Count_and_Accumulate (Proj3_brocharg.asm		     Page 1 - 1


				TITLE Count_and_Accumulate (Proj3_brocharg.asm)

				; Author: Glen Brochard
				; Last Modified: 10/21/2022
				; OSU email address: brocharg@oregonstate.edu
				; Course number/section: CS271 Section 400
				; Project Number: 3      Due Date: 10/30/2022
				; Description: Program that displays title and programmer name; prompts user for his/her name; provides
				; instructions for input (valid ranges) and instructions to terminate input and display stats on valid
				; entries; loops user input prompt until user enters a non-negative number; validates input as negative
				; and within bounds of ranges (as constants lower_one, upper_one, lower_two, upper_two); calculates count,
				; sum, minimum, maximum, rounded average (>.51 gets rounded 'up', <= .50 gets rounded 'down'), as well
				; as the actual decimal average (to one-hundreth place) without utilizing the FPU; displays all of the 
				; these stats; displays special message if no valid numbers were entered, then displays a closing message 
				; to the user including his/her name

				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 

 =-000000C8			LOWER_ONE = -200
 =-00000064			UPPER_ONE = -100
 =-00000032			LOWER_TWO = -50
 =-00000001			UPPER_TWO = -1

 00000000			.data

 00000000 2A 2A 2A 2A 2A	programTitle       BYTE  "**********Counting, Accumulating, and Stats! by",0                        ; program title for display
	   2A 2A 2A 2A 2A
	   43 6F 75 6E 74
	   69 6E 67 2C 20
	   41 63 63 75 6D
	   75 6C 61 74 69
	   6E 67 2C 20 61
	   6E 64 20 53 74
	   61 74 73 21 20
	   62 79 00
 00000030 20 47 6C 65 6E	programmerName     BYTE  " Glen M. Brochard (nezcoupe)**********",0
	   20 4D 2E 20 42
	   72 6F 63 68 61
	   72 64 20 28 6E
	   65 7A 63 6F 75
	   70 65 29 2A 2A
	   2A 2A 2A 2A 2A
	   2A 2A 2A 00
 00000057  00000021 [		userName           BYTE  33 DUP(0)                           ; storage for user name input
	    00
	   ]
 00000078 50 6C 65 61 73	userNamePrompt     BYTE  "Please give me your handle: ",0    ; get userName
	   65 20 67 69 76
	   65 20 6D 65 20
	   79 6F 75 72 20
	   68 61 6E 64 6C
	   65 3A 20 00
 00000095 49 74 27 73 20	userGreet          BYTE  "It's a pleasure, ",0
	   61 20 70 6C 65
	   61 73 75 72 65
	   2C 20 00
 000000A7 50 6C 65 61 73	instructions       BYTE  "Please enter any numbers between[-200, -100] or [-50, -1].",0
	   65 20 65 6E 74
	   65 72 20 61 6E
	   79 20 6E 75 6D
	   62 65 72 73 20
	   62 65 74 77 65
	   65 6E 5B 2D 32
	   30 30 2C 20 2D
	   31 30 30 5D 20
	   6F 72 20 5B 2D
	   35 30 2C 20 2D
	   31 5D 2E 00
 000000E2 54 6F 20 66 69	instructions2      BYTE  "To finish the program and see input stats, please enter",0
	   6E 69 73 68 20
	   74 68 65 20 70
	   72 6F 67 72 61
	   6D 20 61 6E 64
	   20 73 65 65 20
	   69 6E 70 75 74
	   20 73 74 61 74
	   73 2C 20 70 6C
	   65 61 73 65 20
	   65 6E 74 65 72
	   00
 0000011A 61 20 6E 6F 6E	instructions3      BYTE  "a non-negative number.",0          ; separated this from instructions2 just for aesthetic
	   2D 6E 65 67 61
	   74 69 76 65 20
	   6E 75 6D 62 65
	   72 2E 00
 00000131 2E 00			fullstop           BYTE  ".",0
 00000133 21 00			exclaim            BYTE  "!",0
 00000135 2E 20 45 6E 74	userNumPrompt      BYTE  ". Enter a number: ",0
	   65 72 20 61 20
	   6E 75 6D 62 65
	   72 3A 20 00
 00000148 00000000		userNum            DWORD ?          ; for storing user input
 0000014C 00000000		minValid           DWORD ?          ; will hold minimum (farthest from zero)
 00000150 FFFFFF38		maxValid           DWORD LOWER_ONE  ; set for initial comparisons, without the program will set maxValid to 0 upon termination
 00000154 00000000		countValid         DWORD ?          ; count of valid entries
 00000158 00000000		sumValid		   DWORD ?          ; sum of valid entries
 0000015C 00000000		averageQuotient    DWORD ?          ; sumValid/countValid quotient
 00000160 00000000		averageRemain      DWORD ?          ; sumValid/countValid remainder
 00000164 00000000		averageQuotDec     DWORD ?          ; for decremented average, so that averageQuotient will not be changed (for display in extra credit)
 00000168 00000000		remMULhund         DWORD ?          ; holds (remainder of (sumValid/countValid) * 100)
 0000016C 00000000		remHundDIVcount    DWORD ?          ; remMULhund / countValid; is the decimal portion of the average for EC 2
 00000170 00000000		remHundDIVcountRem DWORD ?          ; will hold the remainder for the decimal portion above to check for .01 rounding for EC 2
 00000174 00000000		decimalRemTen      DWORD ?          ; holds remHundDIVcountRem * 10 for EC 2
 00000178 00000000		decimalRemTenDIV   DWORD ?          ; holds decimalRemTen / countValid to check for rounding rule for EC 2
 0000017C 54 68 69 73 20	invalidMessage     BYTE  "This number is not within the ranges specified.",0           ; error message for invalid entries
	   6E 75 6D 62 65
	   72 20 69 73 20
	   6E 6F 74 20 77
	   69 74 68 69 6E
	   20 74 68 65 20
	   72 61 6E 67 65
	   73 20 73 70 65
	   63 69 66 69 65
	   64 2E 00
 000001AC 4E 6F 20 76 61	noValidMessage     BYTE  "No valid numbers were entered.",0                            ; display special message for no valid entries
	   6C 69 64 20 6E
	   75 6D 62 65 72
	   73 20 77 65 72
	   65 20 65 6E 74
	   65 72 65 64 2E
	   00
 000001CB 54 68 65 20 63	countMessage       BYTE  "The count of valid numbers entered is: ",0
	   6F 75 6E 74 20
	   6F 66 20 76 61
	   6C 69 64 20 6E
	   75 6D 62 65 72
	   73 20 65 6E 74
	   65 72 65 64 20
	   69 73 3A 20 00
 000001F3 54 68 65 20 73	sumMessage         BYTE  "The sum of valid numbers entered is: ",0
	   75 6D 20 6F 66
	   20 76 61 6C 69
	   64 20 6E 75 6D
	   62 65 72 73 20
	   65 6E 74 65 72
	   65 64 20 69 73
	   3A 20 00
 00000219 54 68 65 20 6D	maxMessage         BYTE  "The maximum valid number entered is: ",0
	   61 78 69 6D 75
	   6D 20 76 61 6C
	   69 64 20 6E 75
	   6D 62 65 72 20
	   65 6E 74 65 72
	   65 64 20 69 73
	   3A 20 00
 0000023F 54 68 65 20 6D	minMessage         BYTE  "The minimum valid number entered is: ",0
	   69 6E 69 6D 75
	   6D 20 76 61 6C
	   69 64 20 6E 75
	   6D 62 65 72 20
	   65 6E 74 65 72
	   65 64 20 69 73
	   3A 20 00
 00000265 54 68 65 20 61	averageMessage     BYTE  "The average valid number entered is: ",0
	   76 65 72 61 67
	   65 20 76 61 6C
	   69 64 20 6E 75
	   6D 62 65 72 20
	   65 6E 74 65 72
	   65 64 20 69 73
	   3A 20 00
 0000028B 54 68 65 20 64	decAverageMessage  BYTE  "The decimal average to the nearest hundreth is: ",0          ; display message for extra credit 2
	   65 63 69 6D 61
	   6C 20 61 76 65
	   72 61 67 65 20
	   74 6F 20 74 68
	   65 20 6E 65 61
	   72 65 73 74 20
	   68 75 6E 64 72
	   65 74 68 20 69
	   73 3A 20 00
 000002BC 53 6F 20 6C 6F	goodbye            BYTE  "So long, and thanks for all the fish, ",0
	   6E 67 2C 20 61
	   6E 64 20 74 68
	   61 6E 6B 73 20
	   66 6F 72 20 61
	   6C 6C 20 74 68
	   65 20 66 69 73
	   68 2C 20 00
 000002E3 00000000		lineCount          DWORD 0          ; will hold extra credit 1 line count
 000002E7 2A 2A 45 43 31	extraCredit1       BYTE  "**EC1: Numbers the lines during user input, increments line number only for valid entries.",0
	   3A 20 4E 75 6D
	   62 65 72 73 20
	   74 68 65 20 6C
	   69 6E 65 73 20
	   64 75 72 69 6E
	   67 20 75 73 65
	   72 20 69 6E 70
	   75 74 2C 20 69
	   6E 63 72 65 6D
	   65 6E 74 73 20
	   6C 69 6E 65 20
	   6E 75 6D 62 65
	   72 20 6F 6E 6C
	   79 20 66 6F 72
	   20 76 61 6C 69
	   64 20 65 6E 74
	   72 69 65 73 2E
	   00
 00000342 2A 2A 45 43 32	extraCredit2       BYTE  "**EC2: Calculates and displays average as decimal point number rounded to nearest .01",0
	   3A 20 43 61 6C
	   63 75 6C 61 74
	   65 73 20 61 6E
	   64 20 64 69 73
	   70 6C 61 79 73
	   20 61 76 65 72
	   61 67 65 20 61
	   73 20 64 65 63
	   69 6D 61 6C 20
	   70 6F 69 6E 74
	   20 6E 75 6D 62
	   65 72 20 72 6F
	   75 6E 64 65 64
	   20 74 6F 20 6E
	   65 61 72 65 73
	   74 20 2E 30 31
	   00

 00000000			.code
 00000000			main PROC

				; ----------------------------------------------------------------
				; display title and programmer name; prompt user to enter userName
				; and then display a greeting with the user's name.
				;
				; ----------------------------------------------------------------
				  
				  ; mov programTitle and Name offsets into EDX and display them with WriteSting
 00000000  BA 00000000 R	  MOV  EDX, OFFSET programTitle
 00000005  E8 00000000 E	  CALL WriteString
 0000000A  BA 00000030 R	  MOV  EDX, OFFSET programmerName
 0000000F  E8 00000000 E	  CALL WriteString
 00000014  E8 00000000 E	  CALL CrLf
 00000019  E8 00000000 E	  CALL CrLf
 0000001E  BA 000002E7 R	  MOV  EDX, OFFSET extraCredit1
 00000023  E8 00000000 E	  CALL WriteString
 00000028  E8 00000000 E	  CALL CrLf
 0000002D  BA 00000342 R	  MOV  EDX, OFFSET extraCredit2
 00000032  E8 00000000 E	  CALL WriteString
 00000037  E8 00000000 E	  CALL CrLf
 0000003C  E8 00000000 E	  CALL CrLf

				  ; ask user name via prompt, get input and store
 00000041  BA 00000078 R	  MOV  EDX, OFFSET userNamePrompt
 00000046  E8 00000000 E	  CALL WriteString
 0000004B  BA 00000057 R	  MOV  EDX, OFFSET userName
 00000050  B9 00000020		  MOV  ECX, 32
 00000055  E8 00000000 E	  CALL ReadString	
 0000005A  E8 00000000 E	  CALL CrLf
				                             
				  ; greet the user including userName
 0000005F  BA 00000095 R	  MOV  EDX, OFFSET userGreet
 00000064  E8 00000000 E	  CALL WriteString
 00000069  BA 00000057 R	  MOV  EDX, OFFSET userName
 0000006E  E8 00000000 E	  CALL WriteString
 00000073  BA 00000131 R	  MOV  EDX, OFFSET fullstop
 00000078  E8 00000000 E	  CALL WriteString
 0000007D  E8 00000000 E	  CALL CrLf
 00000082  E8 00000000 E	  CALL CrLf

				; ---------------------------------------------------------------
				; display instructions for program use; tell user what range of 
				; input values will be considered valid and how to terminate the
				; entry of more values and see the calculations that the program
				; provides
				;
				; Section could possibly be rolled into the logical section above
				;
				; ---------------------------------------------------------------

				  ; mov instruction offsets in EDX and display them with WriteString
 00000087  BA 000000A7 R	  MOV  EDX, OFFSET instructions
 0000008C  E8 00000000 E	  CALL WriteString
 00000091  E8 00000000 E	  CALL CrLf
 00000096  BA 000000E2 R	  MOV  EDX, OFFSET instructions2
 0000009B  E8 00000000 E	  CALL WriteString
 000000A0  E8 00000000 E	  CALL CrLf
 000000A5  BA 0000011A R	  MOV  EDX, OFFSET instructions3
 000000AA  E8 00000000 E	  CALL WriteString
 000000AF  E8 00000000 E	  CALL CrLf
 000000B4  E8 00000000 E	  CALL CrLf

				; -------------------------------------------------------------------
				; Main user entry loop to get input and validate.
				; 
				; 1) prompt user to enter number; repeat until user enters non-negative 
				; number with first validation 2) then again validate in this order: 
				; is input non-negative?, is input in lower set of OR condition 
				; {-200,...,-100}?, is input in upper set of OR condition {-50,...,-1}? 
				; 3) Displays invalid input message and restarts loops
				; 4) counts the validated inputs 5) increments sum of validated inputs
				; 6) finds min and max of valid inputs and sets values of minValid and 
				; maxValid accordingly
				;
				; The min and max value variable setting, as well as sum increment,
				; could be placed in logical section below this one (for calculations)
				; - however it works well organized like this, in code and in my head
				; 
				; -------------------------------------------------------------------

				  ; begin loop with prompt "Enter a number: " and continue loop until user terminates
 000000B9			_topOfLoop:
 000000B9  A1 000002E3 R	  MOV  EAX, lineCount
 000000BE  E8 00000000 E	  CALL WriteDec
 000000C3  BA 00000135 R	  MOV  EDX, OFFSET userNumPrompt
 000000C8  E8 00000000 E	  CALL WriteString
 000000CD  E8 00000000 E	  CALL ReadInt
 000000D2  A3 00000148 R	  MOV  userNum, EAX

				  ; check for non-negative input and terminate loop (skip to proper _displayCalcs) if so
 000000D7			_validateNonNegative:
 000000D7  A1 00000148 R	  MOV  EAX, userNum
 000000DC  83 F8 00		  CMP  EAX, 0					     ; if userNum is negative, SF will set to 1
 000000DF  79 73		  JNS  _displayCalcs			     ; if SF = 0, jump to _displayCalcs code label
				  
				  ; if input validated as negative, validate for range [-200, -100]
 000000E1			_validateOne:                
 000000E1  A1 00000148 R	  MOV  EAX, userNum
 000000E6  3D FFFFFF38		  CMP  EAX, LOWER_ONE			     ; compare userNum in EAX to constant -200
 000000EB  7C 53		  JL   _invalidate				     ; if userNum is less than -200, jmp to invalidate code label
 000000ED  83 F8 9C		  CMP  EAX, UPPER_ONE			     ; compare userNum in EAX to constant -100
 000000F0  7F 02		  JG   _validateTwo				     ; if userNum is greater than -100, jmp to the second validation - if this fails then the input is valid - jmp to countValid label
 000000F2  EB 0C		  JMP  _countValid

				  ; if input is not within first range, validate for [-50, -1]
 000000F4			_validateTwo:
 000000F4  83 F8 CE		  CMP  EAX, LOWER_TWO			     ; compare userNum in EAX to constant -50
 000000F7  7C 47		  JL   _invalidate				     ; if userNum is less than, invalidate
 000000F9  83 F8 FF		  CMP  EAX, UPPER_TWO			     ; compare userNum in EAX to constant -1
 000000FC  7F 42		  JG   _invalidate				     ; if userNum is greater than, invalidate
 000000FE  EB 00		  JMP  _countValid				     ; validateOne or validateTwo have been passed, jmp to countValid

				  ; count, accumulate, and set min/max values for the valid numbers
 00000100			_countValid:
 00000100  FF 05 00000154 R	  INC  countValid                    ; increment the valid count by 1
 00000106  FF 05 000002E3 R	  INC  lineCount
 0000010C  A1 00000158 R	  MOV  EAX, sumValid
 00000111  03 05 00000148 R	  ADD  EAX, userNum                  ; add the current valid userNum to the current sumValid value in EAX
 00000117  A3 00000158 R	  MOV  sumValid, EAX                 ; mov new sum into indentifier
 0000011C  A1 00000148 R	  MOV  EAX, userNum
 00000121  3B 05 0000014C R	  CMP  EAX, minValid                 ; compare userNum to the current minimum
 00000127  7F 05		  JG   _checkMax                     ; if userNum >= minValid skip over minValid setting to _checkMax
 00000129  A3 0000014C R	  MOV  minValid, EAX                 ; if userNum < minValid, userNum becomes new minValid and continue to _checkMax

				  ; check in userNum is new maximum
 0000012E			_checkMax:
 0000012E  3B 05 00000150 R	  CMP  EAX, maxValid                 ; compare userNum to the current maximum
 00000134  7E 83		  JNG  _topOfLoop                    ; if userNum <= maxValid, skip to _topOfLoop
 00000136  A3 00000150 R	  MOV  maxValid, EAX                 ; if userNum > maxValid, set maxValid and then jmp to _topOfLoop
 0000013B  E9 FFFFFF79		  JMP  _topOfLoop
				                                   
				  ; notify user for negative numbers not in range; restart entry loop
 00000140			_invalidate:
 00000140  BA 0000017C R	  MOV  EDX, OFFSET invalidMessage
 00000145  E8 00000000 E	  CALL WriteString
 0000014A  E8 00000000 E	  CALL CrLf
 0000014F  E9 FFFFFF65		  JMP  _topOfLoop                    ; restart loop after invalid input message


				; ------------------------------------------------------------------
				; 1) display count, sum, minimum and maximum of valid inputs 2) includes 
				; calculations to get the average of the valid inputs as well as the 
				; instructions to correctly round that average up if remainder >.5 
				; and do-nothing if remainder <=.5 3) displays the correct integer 
				; average 3) calculates the correct decimal average 
				; by using the quotient of 
				; (averageRem*100)/countValid as a way to find the value of the decimal to
				; hundreths place 4) round this to nearest .01 by comparing the remainder*10
				; /countValid of that process (which would yield the thousandths value) to 
				; 5 (if greater or equal, increment hundreths place) 4) display the correct 
				; rounded or non-rounded decimal by writing the non-rounded averageQuotient, 
				; a "." stop, and the 2 digit 'decimal' portion of the overall value
				;
				; ------------------------------------------------------------------

 00000154			_displayCalcs:
				  ; count of validated numbers (if no valid entered skip to parting message)
 00000154  A1 00000154 R	  MOV  EAX, countValid
 00000159  83 F8 00		  CMP  EAX, 0
 0000015C  0F 84 0000019F	  JE   _partingZero                  ; if countValid = 0 then jump to special case parting message
 00000162  E8 00000000 E	  CALL CrLf
 00000167  BA 000001CB R	  MOV  EDX, OFFSET countMessage 
 0000016C  E8 00000000 E	  CALL WriteString                   ; display valid count message and unsigned integer value (dec chosen because count will only be positive, looks cleaner)
 00000171  E8 00000000 E	  CALL WriteDec
 00000176  E8 00000000 E	  CALL CrLf
				              
				  ; sum of valid numbers
 0000017B  BA 000001F3 R	  MOV  EDX, OFFSET sumMessage
 00000180  E8 00000000 E	  CALL WriteString                   
 00000185  A1 00000158 R	  MOV  EAX, sumValid
 0000018A  E8 00000000 E	  CALL WriteInt                      ; display signed integer sum to handle negative inputs
 0000018F  E8 00000000 E	  CALL CrLf
												   
				  ; minimum (farthest from 0) valid entered
 00000194  BA 0000023F R	  MOV  EDX, OFFSET minMessage
 00000199  E8 00000000 E	  CALL WriteString                   
 0000019E  A1 0000014C R	  MOV  EAX, minValid
 000001A3  E8 00000000 E	  CALL WriteInt                      ; display signed integer minimum valid entry
 000001A8  E8 00000000 E	  CALL CrLf

				  ; maximum (closet to 0) valid user value entered
 000001AD  BA 00000219 R	  MOV  EDX, OFFSET maxMessage
 000001B2  E8 00000000 E	  CALL WriteString                  
 000001B7  A1 00000150 R	  MOV  EAX, maxValid
 000001BC  E8 00000000 E	  CALL WriteInt                      ; display signed integer maximum valid entry
 000001C1  E8 00000000 E	  CALL CrLf

				  ; average (sumValid/countValid); quotient and remainder will be used in roundAverage as well as decimalAverage
 000001C6  A1 00000158 R	  MOV  EAX, sumValid                
 000001CB  99			  CDQ                                ; sign extend value in EAX to EDX:EAX
 000001CC  F7 3D 00000154 R	  IDIV countValid                    
 000001D2  A3 0000015C R	  MOV  averageQuotient, EAX          ; mov quotient from EAX into quotient identifier
 000001D7  89 15 00000160 R	  MOV  averageRemain, EDX            ; mov remainder from EDX into remainder identifer
											
				  ; 20.01 to 20.5 rounds down, 20.51-20.99 rounds up; i.e. > .5 decimal remainder gets rounded up, <= .5 round down
 000001DD			_checkRoundAverage:
 000001DD  A1 00000160 R	  MOV  EAX, averageRemain            ; MUL remainder by 100
 000001E2  BB 00000064		  MOV  EBX, 100
 000001E7  F7 EB		  IMUL EBX							
 000001E9  A3 00000168 R	  MOV  remMULhund, EAX
 000001EE  F7 1D 00000168 R	  NEG  remMULhund                    ; change negative value to positive value because we want to be able to call WriteDec on line 286 to avoid the sign and
				                                     ; the 2's complement of unsigned and signed positive values is the same - so we need this for execution
 000001F4  A1 00000168 R	  MOV  EAX, remMULhund               
 000001F9  99			  CDQ                                ; sign extend to EDX
 000001FA  8B 1D 00000154 R	  MOV  EBX, countValid               ; move countValid to EBX as divisor
 00000200  F7 FB		  IDIV EBX                           ; divide remMULhund, which is (averageRemainder * 100), by valid count
 00000202  A3 0000016C R	  MOV  remHundDIVcount, EAX          ; store EAX into identifier which will be the post-'decimal' display for the decimal average
 00000207  89 15 00000170 R	  MOV  remHundDIVcountRem, EDX       ; store EDX into identifier which will be used in the rounding rule for the decimal portion of the decimal average
 0000020D  A1 0000016C R	  MOV  EAX, remHundDIVcount          
 00000212  83 F8 32		  CMP  EAX, 50                     
 00000215  7E 26		  JLE  _displayNonRoundedAverage     ; if the (remainder * 100) / countValid is less or equal to 50, skip to display non rounded average                                
 00000217  A1 0000015C R	  MOV  EAX, averageQuotient          ; if > 50, continue execution here to decrement the quotient 'up'
 0000021C  48			  DEC  EAX                           
 0000021D  A3 00000164 R	  MOV  averageQuotDec, EAX           ; store decremented quotient into separate identifier so that _displayDecimalAverage can still utilize averageQuotient as-is
				                                     
				  ; display rounded average
 00000222  BA 00000265 R	  MOV  EDX, OFFSET averageMessage
 00000227  E8 00000000 E	  CALL WriteString
 0000022C  A1 00000164 R	  MOV  EAX, averageQuotDec           ; displays proper (rounded) integer average
 00000231  E8 00000000 E	  CALL WriteInt
 00000236  E8 00000000 E	  CALL CrLf
 0000023B  EB 1E		  JMP  _checkDecimalAverageRound

				  ; display the non-decremented quotient for jcond skip above
 0000023D			_displayNonRoundedAverage:
 0000023D  BA 00000265 R	  MOV  EDX, OFFSET averageMessage
 00000242  E8 00000000 E	  CALL WriteString
 00000247  A1 0000015C R	  MOV  EAX, averageQuotient          ; displays proper (non-rounded) integer average
 0000024C  E8 00000000 E	  CALL WriteInt
 00000251  E8 00000000 E	  CALL CrLf
 00000256  E8 00000000 E	  CALL CrLf          
				  
				  ; check remainder of the decimal portion found above for rounding to nearest .01; 
 0000025B			_checkDecimalAverageRound:
 0000025B  A1 00000170 R	  MOV  EAX, remHundDIVcountRem
 00000260  BB 0000000A		  MOV  EBX, 10     
 00000265  F7 E3		  MUL  EBX                           ; mul remainder by 10
 00000267  A3 00000174 R	  MOV  decimalRemTen, EAX    
 0000026C  A1 00000174 R	  MOV  EAX, decimalRemTen
 00000271  99			  CDQ
 00000272  8B 1D 00000154 R	  MOV  EBX, countValid
 00000278  F7 F3		  DIV  EBX                           ; div by 3 again for find what is the thousandth's place for the original average
 0000027A  A3 00000178 R	  MOV  decimalRemTenDIV, EAX
 0000027F  A1 00000178 R	  MOV  EAX, decimalRemTenDIV
 00000284  83 F8 05		  CMP  EAX, 5                        ; check if decimalRemTenDIV is less than 5; if so jcond jmp to display non-rounded version of decimal
 00000287  7C 3F		  JL   _displayNonRoundedDecimal

				  ; display extra credit rounded decimal average
 00000289			_displayRoundedDecimal:
 00000289  FF 05 0000016C R	  INC  remHundDIVcount               ; if jcond fails, continue here to increment the decimal up one-hundreth
 0000028F  BA 0000028B R	  MOV  EDX, OFFSET decAverageMessage ; mov decimal-average message offset into EDX
 00000294  E8 00000000 E	  CALL WriteString                   
 00000299  A1 0000015C R	  MOV  EAX, averageQuotient          ; display non-rounded quotient
 0000029E  E8 00000000 E	  CALL WriteInt
 000002A3  BA 00000131 R	  MOV  EDX, OFFSET fullstop          ; display 'decimal'
 000002A8  E8 00000000 E	  CALL WriteString
 000002AD  A1 0000016C R	  MOV  EAX, remHundDIVcount          ; display rounded decimal (to hundreths)
 000002B2  E8 00000000 E	  CALL WriteDec                      ; write dec here to avoid sign, why NEG was used above to make the signed look same as unsigned
 000002B7  E8 00000000 E	  CALL CrLf
 000002BC  E8 00000000 E	  CALL CrLf
 000002C1  E8 00000000 E	  CALL CrLf
 000002C6  EB 52		  JMP _partingMessage

				  ; display extra credit non-rounded decimal average
 000002C8			_displayNonRoundedDecimal:
 000002C8  BA 0000028B R	  MOV  EDX, OFFSET decAverageMessage ; mov decimal-average message offset into EDX
 000002CD  E8 00000000 E	  CALL WriteString                   
 000002D2  A1 0000015C R	  MOV  EAX, averageQuotient          ; display non-rounded quotient
 000002D7  E8 00000000 E	  CALL WriteInt
 000002DC  BA 00000131 R	  MOV  EDX, OFFSET fullstop          ; display 'decimal'
 000002E1  E8 00000000 E	  CALL WriteString
 000002E6  A1 0000016C R	  MOV  EAX, remHundDIVcount          
 000002EB  E8 00000000 E	  CALL WriteDec                      ; write dec here to avoid sign, why NEG was used above to make the signed look same as unsigned
 000002F0  E8 00000000 E	  CALL CrLf
 000002F5  E8 00000000 E	  CALL CrLf
 000002FA  E8 00000000 E	  CALL CrLf
 000002FF  EB 19		  JMP  _partingMessage               ; skip _partingZero (which is the special case) straight to _partingMessage
				       
				       
				; -----------------------------------------------------------
				; parting message with user's name; includes code for special 
				; message display if no valid numbers were entered (countValid
				; = 0)
				;
				; -----------------------------------------------------------

				  ; special message for no valid entries
 00000301			_partingZero:
 00000301  E8 00000000 E	  CALL CrLf
 00000306  BA 000001AC R	  MOV  EDX, OFFSET noValidMessage
 0000030B  E8 00000000 E	  CALL WriteString
 00000310  E8 00000000 E	  CALL CrLf
 00000315  E8 00000000 E	  CALL CrLf

				  ; parting message with userName
 0000031A			_partingMessage:
 0000031A  BA 000002BC R	  MOV  EDX, OFFSET goodbye
 0000031F  E8 00000000 E	  CALL WriteString
 00000324  BA 00000057 R	  MOV  EDX, OFFSET userName
 00000329  E8 00000000 E	  CALL WriteString
 0000032E  BA 00000133 R	  MOV  EDX, OFFSET exclaim
 00000333  E8 00000000 E	  CALL WriteString
 00000338  E8 00000000 E	  CALL CrLf
				                                    
					Invoke ExitProcess,0	        ; exit to operating system
 0000033D  6A 00	   *	    push   +000000000h
 0000033F  E8 00000000 E   *	    call   ExitProcess
 00000344			main ENDP

				END main
Microsoft (R) Macro Assembler Version 14.29.30146.0	    10/30/22 17:41:51
)Count_and_Accumulate (Proj3_brocharg.asm		     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000398 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000344 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000344 Public STDCALL
  _topOfLoop . . . . . . . . . .	L Near	 000000B9 _TEXT	
  _validateNonNegative . . . . .	L Near	 000000D7 _TEXT	
  _validateOne . . . . . . . . .	L Near	 000000E1 _TEXT	
  _validateTwo . . . . . . . . .	L Near	 000000F4 _TEXT	
  _countValid  . . . . . . . . .	L Near	 00000100 _TEXT	
  _checkMax  . . . . . . . . . .	L Near	 0000012E _TEXT	
  _invalidate  . . . . . . . . .	L Near	 00000140 _TEXT	
  _displayCalcs  . . . . . . . .	L Near	 00000154 _TEXT	
  _checkRoundAverage . . . . . .	L Near	 000001DD _TEXT	
  _displayNonRoundedAverage  . .	L Near	 0000023D _TEXT	
  _checkDecimalAverageRound  . .	L Near	 0000025B _TEXT	
  _displayRoundedDecimal . . . .	L Near	 00000289 _TEXT	
  _displayNonRoundedDecimal  . .	L Near	 000002C8 _TEXT	
  _partingZero . . . . . . . . .	L Near	 00000301 _TEXT	
  _partingMessage  . . . . . . .	L Near	 0000031A _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
LOWER_ONE  . . . . . . . . . . .	Number	 -000000C8h   
LOWER_TWO  . . . . . . . . . . .	Number	 -00000032h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
UPPER_ONE  . . . . . . . . . . .	Number	 -00000064h   
UPPER_TWO  . . . . . . . . . . .	Number	 -00000001h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
averageMessage . . . . . . . . .	Byte	 00000265 _DATA	
averageQuotDec . . . . . . . . .	DWord	 00000164 _DATA	
averageQuotient  . . . . . . . .	DWord	 0000015C _DATA	
averageRemain  . . . . . . . . .	DWord	 00000160 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
countMessage . . . . . . . . . .	Byte	 000001CB _DATA	
countValid . . . . . . . . . . .	DWord	 00000154 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
decAverageMessage  . . . . . . .	Byte	 0000028B _DATA	
decimalRemTenDIV . . . . . . . .	DWord	 00000178 _DATA	
decimalRemTen  . . . . . . . . .	DWord	 00000174 _DATA	
exclaim  . . . . . . . . . . . .	Byte	 00000133 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
extraCredit1 . . . . . . . . . .	Byte	 000002E7 _DATA	
extraCredit2 . . . . . . . . . .	Byte	 00000342 _DATA	
fullstop . . . . . . . . . . . .	Byte	 00000131 _DATA	
goodbye  . . . . . . . . . . . .	Byte	 000002BC _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
instructions2  . . . . . . . . .	Byte	 000000E2 _DATA	
instructions3  . . . . . . . . .	Byte	 0000011A _DATA	
instructions . . . . . . . . . .	Byte	 000000A7 _DATA	
invalidMessage . . . . . . . . .	Byte	 0000017C _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
lineCount  . . . . . . . . . . .	DWord	 000002E3 _DATA	
magenta  . . . . . . . . . . . .	Number	 00000005h   
maxMessage . . . . . . . . . . .	Byte	 00000219 _DATA	
maxValid . . . . . . . . . . . .	DWord	 00000150 _DATA	
minMessage . . . . . . . . . . .	Byte	 0000023F _DATA	
minValid . . . . . . . . . . . .	DWord	 0000014C _DATA	
noValidMessage . . . . . . . . .	Byte	 000001AC _DATA	
programTitle . . . . . . . . . .	Byte	 00000000 _DATA	
programmerName . . . . . . . . .	Byte	 00000030 _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
remHundDIVcountRem . . . . . . .	DWord	 00000170 _DATA	
remHundDIVcount  . . . . . . . .	DWord	 0000016C _DATA	
remMULhund . . . . . . . . . . .	DWord	 00000168 _DATA	
sumMessage . . . . . . . . . . .	Byte	 000001F3 _DATA	
sumValid . . . . . . . . . . . .	DWord	 00000158 _DATA	
userGreet  . . . . . . . . . . .	Byte	 00000095 _DATA	
userNamePrompt . . . . . . . . .	Byte	 00000078 _DATA	
userName . . . . . . . . . . . .	Byte	 00000057 _DATA	
userNumPrompt  . . . . . . . . .	Byte	 00000135 _DATA	
userNum  . . . . . . . . . . . .	DWord	 00000148 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
