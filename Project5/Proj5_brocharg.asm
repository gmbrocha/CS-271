TITLE Randomize! Sorterize! Counterize!     (Proj5_brocharg.asm)

; Author: Glen M. Brochard
; Last Modified: 11/16/2022
; OSU email address: brocharg@oregonstate.edu
; Course number/section: CS271 Section 400
; Project Number: 5      Due Date: 11/19/202
; Description: This program uses mostly referencing indirectly, base+offset, or other method (other than using global constants)
;              to perform the following: The main procedure calls a basic introductory procedure, followed by the fillArray
;              procedure which generates an array of random integers in the range and number of specified by the global constants.
;              The next call in main is to displayList which iterates through randArray word list and prints each element to 
;              the console; that list is then sorted (by insertion) by a call to sortList - the sorted list is then utilized by 
;              the displayMedian procedure to find and display the median value in the array. Another call to display list will
;              print the sorted list to console. An array (counts) is generated by a call to countList that iterates and counts 
;              the instances of each integer generated in randArray. displayList is called a 3rd time in main to iterate and print
;              counts to the console. **the lists generated all have the array length as the 1st element of the array - this was
;              done after countless hours spent trying to figure out a good way to use displayList for every array

INCLUDE Irvine32.inc

ARRAYSIZE = 100
LO = 15
HI = 25

.data

intro1      BYTE  "                       ***Randomize! Sorterize! Counterize!***",0Ah,
                  "                             *** by Glen M. Brochard ***",0   
intro2      BYTE  "| This program generates a random array of integers in range and number specified by |",0Ah,
                  "| constants in code. It provides procedures that display the median value, sorts and |",0Ah,
				  "| displays a list of the number of instances of each integer that are generated in   |",0Ah,
				  "| ascending order from the lowest range to the highest.                              |",0
randArray   WORD  ARRAYSIZE + 4 DUP(?)                       ; 4 word elements added to this and counts array just as allocated space for safety                 
unsortArray BYTE  "This is the unsorted array:",0Ah,
                  "---------------------------",0
sortArray   BYTE  "This is the sorted array:",0Ah,
                  "-------------------------",0
medianArray BYTE  "This is the median of the array: ",0
counts      WORD  HI - LO + 4 DUP(?)                               
countsMsg   BYTE  "This is a list of instances of each number generated:",0Ah,
                  "-----------------------------------------------------",0
countsVals  WORD  HI - LO + 4 DUP(?)

.code
main PROC

  CALL Randomize

  PUSH OFFSET intro2
  PUSH OFFSET intro1
  CALL introduction

  PUSH OFFSET randArray
  CALL fillArray            ; fill randArray with random integers based on seed generated with Randomize call above

  PUSH OFFSET unsortArray
  PUSH OFFSET randArray
  CALL displayList          ; display unsorted randArray list

  PUSH OFFSET randArray
  CALL sortList             ; sort randArray

  PUSH OFFSET medianArray
  PUSH OFFSET randArray
  CALL displayMedian        ; find and display median value in sorted randArray list

  PUSH OFFSET sortArray
  PUSH OFFSET randArray
  CALL displayList          ; display sorted randArray list

  PUSH OFFSET counts
  PUSH OFFSET randArray
  CALL countList            ; generate list of counts of instances of integers in randArray
  
  PUSH OFFSET countsMsg
  PUSH OFFSET counts
  CALL displayList          ; display counts list

	Invoke ExitProcess,0	; exit to operating system
main ENDP

; ---------------------------------------------------------
; introduction for program with title and programmer name; 
; Preconditions: Program description OFFSET passed as first 
; parameter on stack by calling procedure. Program title 
; OFFSET passed as second parameter on stack by calling 
; procedure. Postconditions: first and second parameter at 
; OFFSETs printed to console.
;
; ---------------------------------------------------------
introduction PROC

  PUSH EBP
  MOV  EBP, ESP
  PUSH EDX
  MOV  EDX, [EBP + 8]       ; ebp + 8 bytes to reference intro1 parameter
  CALL WriteString
  CALL CrLf
  CALL CrLf
  MOV  EDX, [EBP + 12]      ; ebp + 12 bytes to reference intro2 parameter
  CALL WriteString
  CALL CrLF
  CALL CrLF
  CALL CrLf
  POP  EDX
  POP  EBP
  RET  8

introduction ENDP

; ------------------------------------------------------------
; procedure to fill array with random integers based on global 
; constants HI, LO, and ARRAYSIZE; uses a simple loop with 
; ARRAYSIZE as the counter; calls RandomRange to produce 
; integers that are then placed into incrementing indices of 
; randArray; Preconditions: array OFFSET with at least ARRAY
; SIZE elements + 2 (ARRAYSIZE + 2 * WORD) pushed to stack; 
; Postconditions: registers used in proc restored to calling 
; procedure state, array at OFFSET passed filled with random 
; integers in range LO - HI for a LENGTHOF ARRAYSIZE
;
; ------------------------------------------------------------

fillArray PROC
  
  ; **important, first element of array created will be the lengthof the array
  PUSH EBP
  MOV  EBP, ESP               ; move ESP into EBP to point to top of stack frame
  PUSH EAX                    ; push registers to preserve during array fill operations
  PUSH ECX
  PUSH ESI
  MOV  ECX, ARRAYSIZE         ; set loop counter to global arrary size
  MOV  ESI, [EBP + 8]         ; move someArray offset into ESI to increment during loop
  MOV  EAX, ARRAYSIZE
  MOV  [ESI], EAX             ; first element will be the arraysize to use in display (otherwise im having difficulty using same display proc for diff array sizes)
  ADD  ESI, TYPE WORD         ; set pointer to next element after array size

_topFillArray:
  MOV  EAX, HI                ; set range to the hi global constant
  INC  EAX                    ; increment because randomrange EAX value isn't inclusive
  CALL RandomRange 
  CMP  EAX, LO                ; if random number less than LO constant fall through
  JGE  _continueFill          ; jcond to continue fill to move random number into memory
  INC  ECX                    ; inc ecx to negate iteration
  JMP  _loop                  ; uncondtionally jump to loop again

_continueFill:         
  MOV  [ESI], EAX             ; move random number (in range) to someArray value in ebx
  ADD  ESI, TYPE WORD         ; inc the address stored in ebx 2 bytes to reference next array element

_loop:
  LOOP _topFillArray    
  POP  ESI                    ; pop preserved registers
  POP  ECX
  POP  EAX
  POP  EBP
  RET  4                      ; dereference someArray offset to move esp pointer to bottom of stack

fillArray ENDP

; ------------------------------------------------------------
; procedure to sort an integer array in ascending order; this
; PROC uses an insertion sort method to iterate over a passed
; array and check the preceding for equality (less/greater);
; replaces the preceding value each time a condition is found;
; basic insertion sort using (i) iterations of an outer loop, 
; a (j) position index and loop counter for an inner sublist
; loop, and a key value based on array position at (i) to 
; compare against. Preconditions: array OFFSET passed on stack
; with element 1 (index 0) containing the length of the array,
; LENGTHOF passed array ARRAYSIZE + 1. Postconditions: array
; at OFFSET sorted (least to greatest), registers used within
; procedure restored to calling procedure state
;
; ------------------------------------------------------------

sortList PROC
   
  PUSH EBP
  MOV  EBP, ESP
  MOV  ECX, 1                 ; counter will begin at 1
  MOV  ESI, [EBP + 8]         ; ESI refers to someArray
  ADD  ESI, 2                 ; ESI now points to second element, as to preserve the 1st element which is the ARRAYSIZE element

_sortOuterLoop:
  CMP  ECX, ARRAYSIZE         ; check ECX counter for arraysize, if equal to, exit loop completely
  JE   _exitLoop
  PUSH ECX                    ; preserve ECX
  MOV  EAX, ECX               ; move current value of ECX into eax and mul by 2 to find 'bytes to' element in someArray
  MOV  EBX, 2
  MUL  EBX
  PUSH ESI                    ; preserve ESI
  ADD  ESI, EAX               ; add current 'bytes to' or index to ESI, begins after 1st element which is the array length, will be used to get 'key'
  XOR  EBX, EBX               ; zero out ebx
  MOV  BX, [ESI]              ; key value = someArray[i], into BX as word
  POP  ESI                    ; restore ESI so the beginning value can be referenced in the inner loop
  MOV  EAX, ECX               ; i value
  DEC  EAX                    ; j = i - 1

_sortInnerLoop: 
  CMP  EAX, 0                 ; if j >= 0, exit inner loop
  JNGE _exitInnerLoop
  PUSH EBX                    ; preserve EBX (key value)
  MOV  EBX, 2                 ; mov and mul EAX (j) by 2 to find randArray[j]
  MUL  EBX
  MOV  CX, [ESI + EAX]        ; array at j (randArray[j])
  DIV  EBX                    ; div EAX by 2 again to restore j
  POP  EBX                    ; restore EBX (key value)
  CMP  CX, BX                 ; cmp randArray[j] and key value, if not greater jump to exit inner loop
  JNG  _exitInnerLoop
  PUSH EBX                    ; preserve key value
  MOV  EBX, 2                 ; mov and mul EAX by 2 again to get randArray[j]
  MUL  EBX
  MOV  [ESI + EAX + 2], CX    ; mov randArray[j] into randArray[j+1]
  DIV  EBX                    ; div EAX by 2 to restore eax to j
  POP  EBX                    ; restore key value
  DEC  EAX                    ; j - 1
  JMP  _sortInnerLoop

_exitInnerLoop:
  PUSH EBX                    ; preserve key value
  MOV  EBX, 2                 ; move and mul EAX by 2 again for randArray[j+1]
  MUL  EBX
  POP  EBX                    ; restore key value
  MOV  [ESI + EAX + 2], BX    ; move key value into randArray[j+1]
  POP  ECX                    ; restore ecx
  INC  ECX                    ; increment ecx counter for comparison to arraysize at top of loop
  JMP  _sortOuterLoop

_exitLoop:
  POP  EBP
  RET  4

sortList ENDP

; -------------------------------------------------------------
; display list parameter; procedure first prints a title of the 
; array passed; then iterates (first element of array = number
; of iterations) over the list and prints the items to the
; console. Will currently display 20 elements per row, with one
; space between each element. Preconditions: title of list 
; OFFSET passed 1st on stack by calling procedure, array to be 
; printed OFFSET passed 2nd by calling procedure; 1st element 
; of array to be printed MUST contain the LENGTHOF the array 
; (-1 to not include the length element itself). Postconditions:
; Array title and array printed to the console and registers 
; restored to the calling procedure state.
;
; -------------------------------------------------------------

displayList PROC

  PUSH EBP
  MOV  EBP, ESP
  PUSHAD
  MOV  EDX, [EBP + 12]        ; reference for title of display passed to procedure
  CALL WriteString
  CALL CrLf
  MOV  ESI, [EBP + 8]         ; reference to first passed parameter - should be an integer array
  XOR  ECX, ECX               ; zero ECX
  MOV  CX, [ESI]              ; move first element into CX (size of array that was passed)
  ADD  ESI, TYPE WORD         ; ESI now references second element, size of array should not be displayed
  MOV  EBX, 1                 ; column counter

_topPrintLoop:
  CMP  CX, 0                  ; compare CX to 0, jcond to exit when 0 is reached (from array length)
  JE   _exitDisplay
  CMP  EBX, 1                 ; compare column to 1, jcond to skipSpace (don't add space before if) if equal
  JE   _skipSpace
  MOV  AL, 20h                ; put ASCII hex code for space into AL
  CALL WriteChar

_skipSpace:
  CMP  EBX, 21                ; compare column number to 21, will display 20 elements before printing a newline
  JNE  _skipNewLine
  CALL CrLf
  MOV  EBX, 1                 ; reset column to 1

_skipNewLine:
  XOR  EAX, EAX               ; zero EAX
  MOV  AX, [ESI]              ; move current ESI into AX for printing
  CALL WriteDec
  ADD  ESI, TYPE WORD         ; reference next element in word array
  DEC  CX                     ; decrement loop counter 
  INC  EBX                    ; increment column count
  JMP  _topPrintLoop

_exitDisplay:
  CALL CrLf
  CALL CrLf
  POPAD
  POP  EBP
  RET  8

displayList ENDP

; -------------------------------------------------------------------
; find and display the median value in randArray; utilizes a sorted
; list of ARRAYSIZE to find the 'middle' values of the list. If the 
; list is an even number LENGTHOF, will get the average of the two
; 'middle' values, round them accordingly and print the rounded/non
; rounded value. For odd lists simply prints the middle value. Pre-
; conditions: Mediant title OFFSET passed as first parameter on 
; stack by calling procedure; array (to find median of) OFFSET with 
; 1st element as LENGTHOF array (-1 to not include length element 
; itself) passed as 2nd parameter by calling procedure. Postcondition
; : median title printed to console; single median of passed array 
; printed to console; registers restored to calling procedure state.
;
; -------------------------------------------------------------------

displayMedian PROC

  PUSH EBP
  MOV  EBP, ESP
  PUSH ECX
  PUSH EAX
  PUSH EBX
  MOV  EDX, [EBP + 12]        ; mov median title array offset into edx for printing
  CALL WriteString
  MOV  ESI, [EBP + 8]         ; this is our randArray reference
  ADD  ESI, TYPE WORD         ; ESI references element after array size element
  MOV  EAX, ARRAYSIZE         ; put arraysize into EAX and div by 2 to get 'middle'
  CDQ
  MOV  EBX, 2
  DIV  EBX
  CMP  EDX, 0                 ; if remainder is zero, the list is even and Jcond falls through to find average to 2 'middle' elements
  JNE  _oddList
  MUL  EBX                    ; EAX contains 'half' of randArray, mul by 2 to find byte number
  ADD  ESI, EAX               ; add byte amount
  MOV  EBX, 0                 ; zero EBX just in case
  MOV  BX, [ESI]              ; move first 'middle' number into BX
  SUB  ESI, 2                 ; sub 2 from ESI that will be added to randArray reference in ESI to get previous 'middle' element
  MOV  EAX, 0                 ; zero EAX just in case
  MOV  AX, [ESI]           
  ADD  AX, BX                 ; add 2 'middle' numbers
  CDQ
  MOV  EBX, 2                 ; move 2 into EBX and div AX by 2 to find average of middle numbers
  DIV  EBX
  CMP  EDX, 0                 ; if average is an integer, jump to noRoundUp
  JE   _noRoundUp
  INC  EAX                    ; average is always of 2 numbers, so if remainder isn't zero, it will always be .5, and needs to be rounded up
  CALL WriteDec
  CALL CrLf
  CALL CrLf
  JMP  _returnMedian

_noRoundUp:                   ; if EDX is zero, above, jcond here and write non rounded even integer
  CALL WriteDec
  CALL CrLf
  CALL CrLf
  JMP  _returnMedian

_oddList:
  MUL  EBX                    ; EAX still contains 'half' of randArray, mul by 2 to find byte number
  ADD  ESI, EAX               ; add byte amount to randArray reference
  MOV  AX, [ESI]              ; move randArray element to EAX and print the element
  CALL WriteDec
  CALL CrLf
  CALL CrLf

_returnMedian:
  POP  EBX
  POP  EAX                    ; restore registers and return to calling procedure
  POP  ECX
  POP  EBP
  RET  8

displayMedian ENDP

; -------------------------------------------------------------------------------
; count number of instances of each number in range hi-lo that were generated 
; into randArray; procedure performs a double loop that (on the outer loop) 
; iterates over possible random generations (set by constants LO and HI), and
; for possible values iterates (in the inner loop) the entirety of the rand
; Array parameter for matches, increasing a count register each match. AFter 
; inner loop exit conditions pass, the count value is placed as subsequent 
; elements of the counts array, beginning at element 2 (index 1); LENGTHOF 
; value of the array (-1 as to not include the length variable itself) is placed 
; as the first element of the counts array. Preconditions: counts array at OFFSET 
; with at least HI - LO WORD + 4 WORD allocated passed as first parameter on the 
; stack by calling procedure; array to be counted OFFSET passed as second para-
; -meter on the stack by calling procedure. Post-conditions: first parameter 
; array at OFFSET filled with counts of instances of values in the range LO to HI 
; appearing in the second parameter array.
;
; -------------------------------------------------------------------------------

countList PROC

  PUSH EBP
  MOV  EBP, ESP
  PUSHAD
  XOR  EAX, EAX
  MOV  AX, LO                 ; will be our current number to compare to randArray values, starting at LO
  MOV  ESI, [EBP + 8]         ; reference for randArray
  ADD  ESI, TYPE WORD         ; ESI now references second element after array size
  MOV  EDI, [EBP + 12]
  XOR  EBX, EBX               ; zero EBX
  MOV  EBX, HI - LO           ; move HI - LO into EBX (number of elements in the count array)
  INC  EBX                    ; inc 1 so # reflects last element
  MOV  [EDI], EBX             ; place number of elements into first element of counts array
  ADD  EDI, TYPE WORD         ; EDI now references second element
  MOV  EBX, 0                 ; counter register to be placed into counts array

_outerLoop:
  CMP  AX, HI                 ; if EAX greater than avaliable numbers (HI) we are finished, jcond to return counts
  JG   _returnCounts
  MOV  ECX, ARRAYSIZE + 1     ; ECX counter for inner loop, will iterate the entirety of the randArray list

_innerLoop:
  CMP  AX, [ESI]              ; compare EAX value to value at ESI (beginning at byte 0, increase 2 bytes per loop)
  JNE  _loopCount             ; if EAX != value, jcond to noCount
  INC  EBX                    ; if EAX = value, inc ebx (count) then drop to loopNoCount

_loopCount:
  ADD  ESI, 2                 ; add 2 bytes to randArray
  LOOP _innerLoop             ; dec ECX, jump back to innerLoop to compare next randArray value to current EAX
  MOV  [EDI], EBX             ; after loop, ebx = counts for EAX (current compare value), move into EDI which references the counts array
  ADD  EDI, TYPE WORD         ; inc edi by 2 bytes to reference next element index
  INC  AX                     ; inc eax to get next compare value for innerLoop
  MOV  EBX, 0                 ; reset counts register to 0
  MOV  ESI, [EBP + 8]         ; reset reference to beginning of randArray
  JMP  _outerLoop             ; unconditionally jump back to _outerLoop with new EAX, reset EBX, and next counts array empty element

_returnCounts:
  POPAD
  POP  EBP
  RET  8
countList ENDP

END main
